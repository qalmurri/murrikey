### DIRECTORY TREE ###
src
├── core
│   ├── input_manager.cpp
│   ├── input_manager.h
│   ├── input_x11.cpp
│   ├── key_mapper.cpp
│   ├── key_mapper_data.cpp
│   ├── key_mapper.h
│   ├── murrikey_app.cpp
│   └── murrikey_app.h
├── main.cpp
├── ui
│   ├── overlay_core.cpp
│   ├── overlay.h
│   ├── overlay_logic.cpp
│   ├── overlay_ui.cpp
│   ├── preferences.cpp
│   ├── preferences.h
│   ├── preferences_ui.cpp
│   ├── screen_selector.cpp
│   └── screen_selector.h
└── utils
    ├── config.cpp
    ├── config.h
    ├── hardware_sync.cpp
    └── hardware_sync.h

4 directories, 22 files

### FILE CONTENT ###
==== src/utils/hardware_sync.h ====
#ifndef HARDWARE_SYNC_H
#define HARDWARE_SYNC_H

struct KeyboardConfig {
    int delay = 500;
    int interval = 30;
    int delayThreshold = 50;
    int rateThreshold = 3;
};

class HardwareSync {
public:
    static KeyboardConfig getKeyboardSettings(void* displayPtr, int pollingIntervalMs = 10);
};

#endif
==== src/utils/config.cpp ====
#include "config.h"
Config& Config::instance() {
    static Config inst;
    return inst;
}
Config::Config() : settings("MyProject", "Murrikey") {}
void Config::save(const QString& key, const QVariant& val) {
    settings.setValue(key, val);
}
QVariant Config::load(const QString& key, const QVariant& def) {
    return settings.value(key, def);
}
==== src/utils/config.h ====
#ifndef CONFIG_H
#define CONFIG_H
#include <QSettings>
#include <QVariant>
#define MODE_KEYSYM 0
#define MODE_KEYCODE 1
class Config {
public:
    static Config& instance();
    void save(const QString& key, const QVariant& val);
    QVariant load(const QString& key, const QVariant& def = QVariant());

private:
    Config();
    QSettings settings;
};
#endif
==== src/utils/hardware_sync.cpp ====
#include "hardware_sync.h"
#include "../utils/config.h"

KeyboardConfig HardwareSync::getKeyboardSettings(void* displayPtr, int pollingIntervalMs) {
    KeyboardConfig config;

    // Ambil dari config, kalau tidak ada pakai angka "Lancar Jaya" kamu kemarin
    // Delay: 500ms, Interval: 30ms (untuk rate 33Hz)
    config.delay = Config::instance().load("repeat_delay", 500).toInt();
    config.interval = Config::instance().load("repeat_interval", 30).toInt();

    // Hitung threshold (asumsi polling 10ms)
    config.delayThreshold = config.delay / pollingIntervalMs;
    config.rateThreshold = config.interval / pollingIntervalMs;

    // Safety lock agar tidak nol
    if (config.delayThreshold < 1) config.delayThreshold = 50;
    if (config.rateThreshold < 1) config.rateThreshold = 3;

    return config;
}
==== src/main.cpp ====
#include <QApplication>
#include "murrikey_app.h"

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);
    app.setQuitOnLastWindowClosed(false);

    MurrikeyApp murrikey;
    murrikey.start();

    return app.exec();
}
==== src/core/murrikey_app.cpp ====
#include "murrikey_app.h"
#include "config.h"
#include <QMenu>
#include <QStyle>
#include <QApplication>
#include <QMessageBox>

MurrikeyApp::MurrikeyApp(QObject *parent) : QObject(parent) {
    setupConnections();
    setupTray();
}

void MurrikeyApp::setupConnections() {
    connect(&input, &InputManager::keyPressed, this, [this](QString name, bool ctrl, bool shift, bool alt) {
        int bsMode = Config::instance().load("backspace_mode", 0).toInt();
        if ((name == "BackSpace" || name == "⌫") && bsMode == 1) {
            overlay.removeLastChar();
        } else {
            overlay.handleKeyPress(name, ctrl, shift, alt);
        }
    });

    connect(&prefs, &PreferencesWindow::configChanged, &overlay, &ScreenkeyOverlay::refresh);
    connect(&prefs, &PreferencesWindow::configChanged, this, [this]() {
        int mode = Config::instance().load("input_mode", 0).toInt();
        input.setMode(mode);
    });
    connect(&inputTimer, &QTimer::timeout, &input, &InputManager::check);
}

void MurrikeyApp::setupTray() {
    tray = new QSystemTrayIcon(qApp->style()->standardIcon(QStyle::SP_ComputerIcon), this);
    QMenu* menu = new QMenu();

    menu->addAction("Preferences", &prefs, &QWidget::show);
    menu->addAction("About", [this]() {
        QMessageBox::about(nullptr, "About Murrikey",
            "<h3>Murrikey v1.0</h3>"
            "<p>Developed by <b>qalmurri</b> on ThinkPad P51.</p>"
            "<p>Built with C++ and Qt6.</p>");
    });
    menu->addSeparator();
    menu->addAction("Quit", qApp, &QCoreApplication::quit);

    tray->setContextMenu(menu);
    tray->show();
}

void MurrikeyApp::start() {
    inputTimer.start(10);
    overlay.show();
}
==== src/core/input_manager.cpp ====
#include <QObject>
#include <QString>
#include "input_manager.h"           // Header ini isinya Qt
#include "../utils/hardware_sync.h"  // Header ini sudah kita bersihkan dari X11
#include "config.h"
#include <X11/Xlib.h>
#include <X11/XKBlib.h>
#include <X11/Xutil.h>
#include <cstring>

InputManager::InputManager() {
    display = XOpenDisplay(NULL);
    memset(old_keys, 0, 32);
    memset(repeatTimers, 0, sizeof(repeatTimers));

    sysConfig = HardwareSync::getKeyboardSettings(display, 10);

    currentMode = Config::instance().load("input_mode", 0).toInt();
}

InputManager::~InputManager() {
    if (display) XCloseDisplay(display);
}

void InputManager::setMode(int mode) {
    currentMode = mode;
}

void InputManager::check() {
    if (!display) return;

    char keys[32];
    XQueryKeymap(display, keys);
    
    XkbStateRec state;
    XkbGetState(display, XkbUseCoreKbd, &state);
    
    bool ctrl  = state.mods & ControlMask;
    bool shift = state.mods & ShiftMask;
    bool alt   = state.mods & Mod1Mask;
    bool caps  = state.mods & LockMask;

    for (int i = 8; i < 256; i++) {
        bool isPressed = keys[i / 8] & (1 << (i % 8));
        bool wasPressed = old_keys[i / 8] & (1 << (i % 8));
    
        if (isPressed) {
            // Ambil KeySym untuk cek apakah ini modifier
            KeySym sym = XkbKeycodeToKeysym(display, i, 0, 0);
            bool isModifier = (sym >= XK_Shift_L && sym <= XK_Hyper_R);
    
            if (!wasPressed) {
                // JANGAN KIRIM jika hanya tombol modifier yang ditekan sendirian
                if (!isModifier) {
                    sendKey(i, ctrl, shift, alt, caps);
                }
                repeatTimers[i] = 0;
            } else {
                // LOGIKA REPEAT: Hanya untuk tombol NON-MODIFIER
                if (!isModifier) {
                    repeatTimers[i]++;
                    if (repeatTimers[i] == sysConfig.delayThreshold) {
                        sendKey(i, ctrl, shift, alt, caps);
                    } else if (repeatTimers[i] > sysConfig.delayThreshold) {
                        if ((repeatTimers[i] - sysConfig.delayThreshold) % sysConfig.rateThreshold == 0) {
                            sendKey(i, ctrl, shift, alt, caps);
                        }
                    }
                }
            }
        } else {
            repeatTimers[i] = 0;
        }
    }
    memcpy(old_keys, keys, 32);
}

void InputManager::sendKey(int keycode, bool ctrl, bool shift, bool alt, bool caps) {
    // 1. Siapkan XKeyEvent tiruan agar XLookupString bisa bekerja
    XKeyEvent event;
    event.display = display;
    event.keycode = keycode;
    event.state   = 0;
    if (shift) event.state |= ShiftMask;
    if (caps)  event.state |= LockMask;
    // Kita sengaja tidak masukkan Ctrl/Alt di state agar XLookupString 
    // tetap mengembalikan karakter aslinya (misal 'c' bukan control-char)

    char buffer[32];
    KeySym sym;
    // 2. Terjemahkan keycode menjadi string asli
    int len = XLookupString(&event, buffer, sizeof(buffer), &sym, NULL);

    QString keyName;
    if (len > 0) {
        buffer[len] = '\0';
        keyName = QString::fromUtf8(buffer);
    } else {
        // Jika bukan karakter (seperti F1, Home, dsb), ambil nama Keysym-nya
        const char* s = XKeysymToString(sym);
        if (s) keyName = QString::fromUtf8(s);
    }

    if (keyName.isEmpty()) return;

    // 3. Normalisasi Nama Tombol
    if (keyName == "\r" || keyName == "Return") keyName = "Enter";
    else if (keyName == "\b" || keyName == "BackSpace") keyName = "⌫";
    else if (keyName == "\t") keyName = "Tab";
    else if (keyName == "Escape") keyName = "Esc";
    else if (keyName == "space" || keyName == " ") keyName = " "; // Pastikan space bersih

    // 4. Kirim ke UI
    emit keyPressed(keyName, ctrl, shift, alt);
}
==== src/core/input_x11.cpp ====
#include "input_manager.h"
#include "key_mapper.h"
#include <X11/Xlib.h>
#include <X11/XKBlib.h>

void InputManager::processKeyChange(const char* keys, bool numLockOn, bool ctrl, bool shift, bool alt, bool caps) {
    for (int i = 0; i < 32; i++) {
        if (keys[i] == old_keys[i]) continue;

        for (int bit = 0; bit < 8; bit++) {
            if ((keys[i] & (1 << bit)) && !(old_keys[i] & (1 << bit))) {
                int keycode = i * 8 + bit;
                QString result;

                if (currentMode == 1) {
                    result = QString("KC_%1").arg(keycode);
                } else {
                    unsigned long sym = XkbKeycodeToKeysym(display, keycode, 0, (shift ^ caps) ? 1 : 0);
                    if (KeyMapper::isModifier(sym)) continue;
                    result = KeyMapper::map(sym, numLockOn);
                }

                if (!result.isEmpty()) {
                    emit keyPressed(result, ctrl, shift, alt);
                }
            }
        }
    }
}
==== src/core/key_mapper_data.cpp ====
#include "key_mapper.h"
#include <X11/keysym.h>

void KeyMapper::loadCache() {
    symbolCache[XK_space]     = " ";
    symbolCache[XK_Return]    = "⏎";
    symbolCache[XK_BackSpace] = "⌫";
    symbolCache[XK_Tab]       = "⇥";
    symbolCache[XK_Escape]    = "⎋";
    symbolCache[XK_Delete]    = "⌦";
    symbolCache[XK_Home]      = "⤒";
    symbolCache[XK_End]       = "⤓";
    symbolCache[XK_Page_Up]   = "⇞";
    symbolCache[XK_Page_Down] = "⇟";

    symbolCache[XK_Left]      = "←";
    symbolCache[XK_Right]     = "→";
    symbolCache[XK_Up]        = "↑";
    symbolCache[XK_Down]      = "↓";

    symbolCache[XK_KP_Insert]   = "Ins";
    symbolCache[XK_KP_End]      = "End";
    symbolCache[XK_KP_Down]     = "↓";
    symbolCache[XK_KP_Page_Down]= "PgDn";
    symbolCache[XK_KP_Left]     = "←";
    symbolCache[XK_KP_Begin]    = "5";
    symbolCache[XK_KP_Right]    = "→";
    symbolCache[XK_KP_Home]     = "Home";
    symbolCache[XK_KP_Up]       = "↑";
    symbolCache[XK_KP_Page_Up]  = "PgUp";
    symbolCache[XK_KP_Delete]   = "Del";
    symbolCache[XK_KP_Enter]    = "⏎";
    symbolCache[XK_KP_Add]      = "+";
    symbolCache[XK_KP_Subtract] = "-";
    symbolCache[XK_KP_Multiply] = "×";
    symbolCache[XK_KP_Divide]   = "÷";

    numlockCache[XK_KP_Insert]   = "0";
    numlockCache[XK_KP_End]      = "1";
    numlockCache[XK_KP_Down]     = "2";
    numlockCache[XK_KP_Page_Down]= "3";
    numlockCache[XK_KP_Left]     = "4";
    numlockCache[XK_KP_Begin]    = "5";
    numlockCache[XK_KP_Right]    = "6";
    numlockCache[XK_KP_Home]     = "7";
    numlockCache[XK_KP_Up]       = "8";
    numlockCache[XK_KP_Page_Up]  = "9";
    numlockCache[XK_KP_Delete]   = ".";

    symbolCache[XK_F1]  = "F1";
    symbolCache[XK_Print] = "⎙";
    symbolCache[XK_Pause] = "Ⅱ";
}
==== src/core/key_mapper.h ====
#ifndef KEY_MAPPER_H
#define KEY_MAPPER_H

#include <QString>
#include <QMap>

class KeyMapper {
public:
    static QString map(unsigned long sym, bool numLockOn);
    static bool isModifier(unsigned long sym);
    static void loadCache();

private:
    static QMap<unsigned long, QString> symbolCache;
    static QMap<unsigned long, QString> numlockCache;
};

#endif
==== src/core/key_mapper.cpp ====
#include "key_mapper.h"
#include "config.h"
#include <QJsonDocument>
#include <QJsonObject>
#include <X11/Xlib.h>
#include <X11/keysym.h>

QMap<unsigned long, QString> KeyMapper::symbolCache;
QMap<unsigned long, QString> KeyMapper::numlockCache; 

QString KeyMapper::map(unsigned long sym, bool numLockOn) {
    if (symbolCache.isEmpty()) loadCache();
    
    char* name = XKeysymToString(sym);
    if (!name) return "";
    QString keyName(name);

    QString jsonStr = Config::instance().load("custom_mapping", "{}").toString();
    QJsonDocument doc = QJsonDocument::fromJson(jsonStr.toUtf8());
    QJsonObject customMap = doc.object();
    
    if (customMap.contains(keyName)) {
        return customMap.value(keyName).toString();
    }

    if (numLockOn && numlockCache.contains(sym)) {
        return numlockCache[sym];
    }
    
    if (symbolCache.contains(sym)) return symbolCache[sym];

    if (keyName == "bracketleft") return "[";
    if (keyName == "bracketright") return "]";
    if (keyName == "semicolon") return ";";
    if (keyName == "apostrophe") return "'";
    
    return keyName;
}

bool KeyMapper::isModifier(unsigned long s) {
    return (s == XK_Control_L || s == XK_Control_R || s == XK_Shift_L || 
            s == XK_Shift_R || s == XK_Alt_L || s == XK_Alt_R || s == XK_Super_L);
}
==== src/core/murrikey_app.h ====
#ifndef MURRIKEY_APP_H
#define MURRIKEY_APP_H

#include <QObject>
#include <QSystemTrayIcon>
#include <QTimer>
#include "overlay.h"
#include "preferences.h"
#include "input_manager.h"

class MurrikeyApp : public QObject {
    Q_OBJECT

public:
    explicit MurrikeyApp(QObject *parent = nullptr);
    void start();

private:
    void setupTray();
    void setupConnections();

    ScreenkeyOverlay overlay;
    PreferencesWindow prefs;
    InputManager input;
    QSystemTrayIcon* tray;
    QTimer inputTimer;
};

#endif
==== src/core/input_manager.h ====
#ifndef INPUT_MANAGER_H
#define INPUT_MANAGER_H
#include <QObject>
#include <QString>
#include "../utils/hardware_sync.h"

typedef struct _XDisplay Display; 

class InputManager : public QObject {
    Q_OBJECT
public:
    InputManager();
    ~InputManager();
    void check(); 
    void setMode(int mode);

signals:
    void keyPressed(QString name, bool ctrl, bool shift, bool alt);

private:
    void processKeyChange(const char* keys, bool numLockOn, bool ctrl, bool shift, bool alt, bool caps);
    void sendKey(int keycode, bool ctrl, bool shift, bool alt, bool caps);
    
    KeyboardConfig sysConfig;
    Display* display;
    char old_keys[32];
    int repeatTimers[256];
    int currentMode;
};

#endif
==== src/ui/overlay_core.cpp ====
#include "overlay.h"
#include <QVBoxLayout>

ScreenkeyOverlay::ScreenkeyOverlay(QWidget *parent) : QWidget(parent) {
    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | 
                   Qt::Tool | Qt::WindowTransparentForInput);
    setAttribute(Qt::WA_TranslucentBackground);

    label = new QLabel(this);
    label->setAlignment(Qt::AlignCenter);
    
    auto* layout = new QVBoxLayout(this);
    layout->addWidget(label);

    hideTimer = new QTimer(this);
    hideTimer->setSingleShot(true);
    
    connect(hideTimer, &QTimer::timeout, this, [this]() {
        clearBuffer();
    });

    buffer.reserve(50); 
    refresh();
}

void ScreenkeyOverlay::showEvent(QShowEvent *event) {
    QWidget::showEvent(event);

#ifdef Q_OS_WIN
    SetWindowPos((HWND)winId(), HWND_TOPMOST, 0, 0, 0, 0, 
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
#endif
}
==== src/ui/preferences.cpp ====
#include "preferences.h"
#include "config.h"
#include "screen_selector.h"
#include <QColorDialog>
#include <QFontDialog>
#include <QJsonDocument>
#include <QJsonObject>

PreferencesWindow::PreferencesWindow() {
    setWindowTitle("Murrikey Settings");
    
    initWidgets();      
    setupLayout();      
    loadSettings();     
    setupConnections(); 
    updatePreview();
}

void PreferencesWindow::loadSettings() {
    ySlider->setValue(Config::instance().load("y_offset", 100).toInt());
    durationSlider->setValue(Config::instance().load("hide_duration", 3000).toInt());
    durationLabel->setText(QString("%1 ms").arg(durationSlider->value()));
    backspaceCombo->setCurrentIndex(Config::instance().load("backspace_mode", 0).toInt());
    modeCombo->setCurrentIndex(Config::instance().load("input_mode", 0).toInt());
    mappingInput->setText(Config::instance().load("custom_mapping", "{}").toString());
    smartFormatSpin->setValue(Config::instance().load("smart_format_threshold", 2).toInt());
}

void PreferencesWindow::setupConnections() {
    connect(selectAreaBtn, &QPushButton::clicked, this, [this]() {
        if (currentSelector) { currentSelector->raise(); return; }
        currentSelector = new ScreenSelector();
        connect(currentSelector, &QObject::destroyed, this, [this]() { currentSelector = nullptr; });
        connect(currentSelector, &ScreenSelector::areaSelected, this, [this](QRect rect) {
            Config::instance().save("x", rect.x());
            Config::instance().save("y", rect.y());
            Config::instance().save("width", rect.width());
            Config::instance().save("height", rect.height());
            emit configChanged();
        });
        currentSelector->show();
    });

    connect(colorBtn, &QPushButton::clicked, this, [this]() {
        QColor c = QColorDialog::getColor(Qt::green, this);
        if (c.isValid()) { Config::instance().save("color", c.name()); emit configChanged(); }
    });

    connect(fontBtn, &QPushButton::clicked, this, [this]() {
        bool ok; QFont f = QFontDialog::getFont(&ok, QFont("Monospace", 36), this);
        if (ok) { Config::instance().save("font_family", f.family()); emit configChanged(); }
    });

    connect(ySlider, &QSlider::valueChanged, this, [this](int v) {
        Config::instance().save("y_offset", v); emit configChanged();
    });

    connect(smartFormatSpin, QOverload<int>::of(&QSpinBox::valueChanged), this, [this](int v) {
        Config::instance().save("smart_format_threshold", v); emit configChanged();
    });

    connect(this, &PreferencesWindow::configChanged, this, &PreferencesWindow::updatePreview);
}

void PreferencesWindow::updatePreview() {
    QString c = Config::instance().load("color", "#00FF00").toString();
    QString f = Config::instance().load("font_family", "Monospace").toString();
    previewLabel->setStyleSheet(QString(
        "font-size: 36px; font-weight: bold; color: %1; font-family: '%2'; "
        "background-color: rgba(20, 20, 20, 220); padding: 20px; "
        "border-radius: 10px; border: 2px solid #333;"
    ).arg(c).arg(f));
}
==== src/ui/screen_selector.cpp ====
#include "screen_selector.h"
#include <QMouseEvent>
#include <QShowEvent>
#include <QGuiApplication>
#include <QScreen>
#include <QPainter>

ScreenSelector::ScreenSelector(QWidget *parent) : QWidget(parent) {
    setAttribute(Qt::WA_DeleteOnClose);
    setAttribute(Qt::WA_TranslucentBackground); // WAJIB: Biar QPainter bisa bikin efek lubang

    setWindowFlags(Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint | Qt::Tool);
    setCursor(Qt::CrossCursor);
    
    // QRubberBand kita buang saja, gantinya pakai variabel isSelecting
    isSelecting = false;
}

void ScreenSelector::showEvent(QShowEvent *event) {
    QWidget::showEvent(event);
    setGeometry(QGuiApplication::primaryScreen()->virtualGeometry());
}

void ScreenSelector::mousePressEvent(QMouseEvent *event) {
    if (event->button() == Qt::LeftButton) {
        origin = event->pos(); // Titik awal klik
        isSelecting = true;
        update();
    }
}

void ScreenSelector::mouseMoveEvent(QMouseEvent *event) {
    mousePos = event->pos(); // Posisi kursor sekarang
    update(); // Ini yang bikin crosshair gerak real-time
}

void ScreenSelector::mouseReleaseEvent(QMouseEvent *event) {
    if (event->button() == Qt::LeftButton) {
        isSelecting = false;
        QRect finalRect = QRect(origin, event->pos()).normalized();
        
        if (finalRect.width() > 10 && finalRect.height() > 10) {
            emit areaSelected(finalRect);
        }
        this->close();
    }
}

void ScreenSelector::keyPressEvent(QKeyEvent *event) {
    if (event->key() == Qt::Key_Escape) this->close();
}

void ScreenSelector::paintEvent(QPaintEvent *event) {
    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    // 1. Gambar Background Gelap (Dimmed) seluruh layar
    painter.fillRect(rect(), QColor(0, 0, 0, 150)); // Hitam transparan

    // 2. Gambar Crosshair (Garis Pembidik Hijau)
    painter.setPen(QPen(QColor(0, 255, 0, 150), 1, Qt::DashLine));
    painter.drawLine(0, mousePos.y(), width(), mousePos.y());
    painter.drawLine(mousePos.x(), 0, mousePos.x(), height());

    if (isSelecting) {
        // Ganti startPos jadi origin sesuai mousePressEvent
        QRect selectionRect = QRect(origin, mousePos).normalized();

        // 3. "Lubangi" Background (Clear Area)
        // Area seleksi jadi bening total
        painter.setCompositionMode(QPainter::CompositionMode_Clear);
        painter.fillRect(selectionRect, Qt::transparent);
        painter.setCompositionMode(QPainter::CompositionMode_SourceOver);

        // 4. Gambar Border Area Seleksi
        painter.setPen(QPen(QColor(0, 255, 0), 2, Qt::SolidLine));
        painter.drawRect(selectionRect);

        // 5. Info Ukuran (Real-time Resolution)
        QString info = QString("%1 x %2").arg(selectionRect.width()).arg(selectionRect.height());
        painter.setPen(Qt::white);
        painter.setFont(QFont("Monospace", 10, QFont::Bold));
        
        // Gambar background teks kecil agar terbaca
        QRect textRect(selectionRect.x(), selectionRect.y() - 25, 100, 20);
        painter.fillRect(textRect, QColor(0, 0, 0, 200));
        painter.drawText(textRect, Qt::AlignCenter, info);
    }
}
==== src/ui/screen_selector.h ====
#ifndef SCREEN_SELECTOR_H
#define SCREEN_SELECTOR_H

#include <QWidget>
#include <QRubberBand>
#include <QPoint>

class ScreenSelector : public QWidget {
    Q_OBJECT
    
public:
    explicit ScreenSelector(QWidget *parent = nullptr);

signals:
    void areaSelected(QRect rect);

protected:
    void showEvent(QShowEvent *event) override; 
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;
    void paintEvent(QPaintEvent *event) override; // Ini yang bikin error "no declaration matches"

private:
    QRubberBand *rubberBand;
    QPoint origin;
    QPoint mousePos; // Ini yang tadi dibilang "not declared in this scope"
    bool isSelecting = false;
};

#endif
==== src/ui/overlay.h ====
#ifndef OVERLAY_H
#define OVERLAY_H

#include <QWidget>
#include <QLabel>
#include <QTimer>
#include <QString>

class ScreenkeyOverlay : public QWidget {
    Q_OBJECT

public:
    explicit ScreenkeyOverlay(QWidget *parent = nullptr);
    void refresh(); 
    void handleKeyPress(QString name, bool ctrl, bool shift, bool alt);
    void removeLastChar();
    void clearBuffer();
    void applyEllipsis();
    void updateBuffer(QString text);

protected:
    void showEvent(QShowEvent *event) override;

private:
    void renderWithHighlight(QString highlightPart);
    QLabel* label;
    QTimer* hideTimer;
    QString buffer;
    QString lastKey;
    int repeatCount = 1;
};

#endif
==== src/ui/preferences.h ====
#ifndef PREFERENCES_H
#define PREFERENCES_H

#include <QDialog>
#include <QLabel>
#include <QSlider>
#include <QComboBox>
#include <QLineEdit>
#include <QSpinBox>
#include <QPushButton>
#include <QVariant>       // WAJIB ADA
#include <QStyleOption>    // UNTUK FIX QStyleOptionFrame / QStyleOptionButton
#include <QStyle> // Tambahkan ini
                  //
class PreferencesWindow : public QDialog {
    Q_OBJECT

public:
    PreferencesWindow();

signals:
    void configChanged();

private:
    void initWidgets();
    void setupLayout();
    void setupConnections();
    void loadSettings();
    void updatePreview();

    QLabel* previewLabel;
    QSlider *ySlider, *durationSlider;
    QLabel *durationLabel;
    QComboBox *backspaceCombo, *modeCombo;
    QLineEdit *mappingInput;
    QSpinBox *smartFormatSpin;
    QPushButton *colorBtn, *fontBtn, *selectAreaBtn;

    class ScreenSelector* currentSelector = nullptr;
};

#endif
==== src/ui/overlay_ui.cpp ====
#include "overlay.h"
#include "config.h"
#include <QGuiApplication>
#include <QScreen>
#include <QCursor>

void ScreenkeyOverlay::refresh() {
    int x = Config::instance().load("x", 400).toInt();
    int y = Config::instance().load("y", 800).toInt();
    int w = Config::instance().load("width", 500).toInt();
    int h = Config::instance().load("height", 100).toInt();

    QString color = Config::instance().load("color", "#00FF00").toString();
    QString font = Config::instance().load("font_family", "Monospace").toString();
    
    this->setMinimumSize(0, 0);
    this->setMaximumSize(16384, 16384);

    this->setGeometry(x, y, w, h);
    
    label->setFixedSize(w, h);
    
    int dynamicFontSize = h * 0.5;

    label->setStyleSheet(QString(
        "font-size: %1px; font-weight: bold; color: %2; font-family: '%3'; "
        "background-color: rgba(20, 20, 20, 220); "
        "border-radius: 10px; border: 2px solid #333;"
        "padding-bottom: 5px;"
    ).arg(dynamicFontSize).arg(color).arg(font));
    
    label->setAlignment(Qt::AlignCenter);
}
==== src/ui/preferences_ui.cpp ====
#include "preferences.h"
#include <QFormLayout>
#include <QVBoxLayout>

void PreferencesWindow::initWidgets() {
    ySlider = new QSlider(Qt::Horizontal);
    ySlider->setRange(10, 500);

    durationSlider = new QSlider(Qt::Horizontal);
    durationSlider->setRange(500, 10000);

    durationLabel = new QLabel();
    colorBtn = new QPushButton("Pick Color");
    fontBtn = new QPushButton("Pick Font");

    backspaceCombo = new QComboBox();
    backspaceCombo->addItem("Show Text [BackSpace]", 0);
    backspaceCombo->addItem("Delete Last Character", 1);

    modeCombo = new QComboBox();
    modeCombo->addItem("Character Mode (KeySym)", 0);
    modeCombo->addItem("Hardware Mode (KeyCode)", 1);

    mappingInput = new QLineEdit();
    mappingInput->setPlaceholderText("Contoh: {\"a\":\"1\", \"s\":\"2\"}");

    smartFormatSpin = new QSpinBox();
    smartFormatSpin->setRange(0, 10);
    smartFormatSpin->setSpecialValueText("Disabled");

    selectAreaBtn = new QPushButton("Select Display Area");
    
    previewLabel = new QLabel("Preview: [Ctrl+Alt+⏎]");
    previewLabel->setAlignment(Qt::AlignCenter);
    previewLabel->setMinimumHeight(120);
}

void PreferencesWindow::setupLayout() {
    auto* mainLayout = new QVBoxLayout(this);
    auto* formLayout = new QFormLayout();

    formLayout->addRow("Overlay Position:", selectAreaBtn);
    formLayout->addRow("Smart Format Threshold:", smartFormatSpin);
    formLayout->addRow("Backspace Behavior:", backspaceCombo);
    formLayout->addRow("Custom Mapping (JSON):", mappingInput);
    formLayout->addRow("Input Detection:", modeCombo);
    formLayout->addRow("Bottom Offset (px):", ySlider);
    formLayout->addRow("Hide Duration (ms):", durationSlider);
    formLayout->addRow("", durationLabel);
    formLayout->addRow("Text Color:", colorBtn);
    formLayout->addRow("Font Family:", fontBtn);

    mainLayout->addLayout(formLayout);
    mainLayout->addWidget(new QLabel("<b>Live Preview:</b>"));
    mainLayout->addWidget(previewLabel);
}
==== src/ui/overlay_logic.cpp ====
#include "overlay.h"
#include "config.h"
#include <QFontMetrics>
#include <QTimer>

void ScreenkeyOverlay::handleKeyPress(QString name, bool ctrl, bool shift, bool alt) {
    if (name.isEmpty()) return;

    // 1. FILTER: Jangan munculkan kalau cuma tombol modifier murni yang dikirim
    if (name.contains("Control") || name.contains("Shift") || 
        name.contains("Alt") || name.contains("Meta") || name.contains("Super")) {
        return; 
    }

    hideTimer->stop();
    int threshold = Config::instance().load("smart_format_threshold", 2).toInt();

    // 2. LOGIKA FORMATTING (Yang tadi hilang)
    QString currentFormatted;
    if (name == "⌫") {
        currentFormatted = " [⌫] ";
    } else {
        QString modifiers = "";
        if (ctrl)  modifiers += "Ctrl+";
        if (alt)   modifiers += "Alt+";
        
        // Shift muncul kalau ada temennya (Ctrl/Alt) atau tombol fungsi (F1, Enter, dll)
        if (shift && (name.length() > 1 || !modifiers.isEmpty())) {
            modifiers += "Shift+";
        }

        if (!modifiers.isEmpty() || name.length() > 1) {
            // Shortcut dibungkus kotak [Ctrl+C]
            currentFormatted = " [" + modifiers + name.toUpper() + "] ";
        } else {
            // Ketikan biasa
            currentFormatted = name;
        }
    }

    // 3. LOGIKA REPEAT (Pakai currentFormatted yang sudah ada isinya)
    if (threshold > 0 && currentFormatted == lastKey && !currentFormatted.trimmed().isEmpty()) {
        repeatCount++;
        if (repeatCount >= threshold) {
            if (repeatCount > threshold) {
                QString prevSuffix = QString(" x%1").arg(repeatCount - 1);
                if (buffer.endsWith(prevSuffix)) {
                    buffer.chop(prevSuffix.length());
                }
            }
            buffer += QString(" x%1").arg(repeatCount);
        } else {
            updateBuffer(currentFormatted);
        }
    } else {
        repeatCount = 1;
        lastKey = currentFormatted;
        updateBuffer(currentFormatted);
    }

    QString highlightPart = (repeatCount >= threshold) ? QString(" x%1").arg(repeatCount) : currentFormatted;
    renderWithHighlight(highlightPart);
    
    hideTimer->start(Config::instance().load("hide_duration", 3000).toInt());
}

void ScreenkeyOverlay::renderWithHighlight(QString highlightPart) {
    int maxWidth = this->width() - 40; 
    QFontMetrics metrics(label->font());
    
    QString fullText = buffer;
    
    if (metrics.horizontalAdvance(fullText) > maxWidth) {
        while (metrics.horizontalAdvance("..." + fullText) > maxWidth && fullText.length() > 0) {
            fullText.remove(0, 1);
        }
        fullText = "..." + fullText;
    }

    label->setTextFormat(Qt::RichText);

    if (fullText.endsWith(highlightPart) && !highlightPart.isEmpty()) {
        QString oldPart = fullText.left(fullText.length() - highlightPart.length());
        label->setText(oldPart + "<u>" + highlightPart + "</u>");
    } else {
        label->setText(fullText);
    }
}

void ScreenkeyOverlay::updateBuffer(QString text) {
    buffer += text;
    if (buffer.length() > 100) buffer = buffer.right(100);
}

void ScreenkeyOverlay::clearBuffer() {
    buffer = ""; 
    label->clear();
    lastKey = "";
    repeatCount = 1;
}

void ScreenkeyOverlay::removeLastChar() {
    hideTimer->stop();
    if (!buffer.isEmpty()) {
        buffer.chop(1);
        renderWithHighlight("");
    }
    int duration = Config::instance().load("hide_duration", 3000).toInt();
    hideTimer->start(duration);
}

void ScreenkeyOverlay::applyEllipsis() {
    renderWithHighlight(""); 
}
